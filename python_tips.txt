1. finally语句块肯定是要执行的，else语句块只会再没有异常时才会执行，
   如果异常父类放在异常子类的前面，异常子类就不会捕获；
   
3. 字符串的strip()方法是用，当strip()有参数时，这个参数可以理解成要删除的字符序列，是否被删除的前提是字符串的开头
    和结尾是不是包含要删除的字符，如果有就继续处理，没有的话就不会删除中间的字符的；
	
4. title()---所有单词的首字母大写，其余小写，非字母后的第一个字母将装换成大写字母；

6. python中二进制用0b加相应数字表示，八进制用0o加相应数字表示，十六进制用0x加相应数字表示；bin()方法可以将其他进制
    的数转换成二进制，oct()将其他进制的数转换成八进制，hex()将其他进制的数转换成十六进制；int()转换成十进制；
	
7. type(('a'))--表示的是str类型，不是tuple类型；

9. 元组对象进行重新赋值或者更新时会导致运行时异常；

10. for vlan_min. vlan_max in [(200, 300)]:
        print(vlan_min, vlan_max)   
	# output:200 300

14. property用法
        属性加个@property装饰器，也就是get方法，set方法加@name.setter，delete方法加@name.deleter；
		如果子类扩展父类的property装饰的属性，
		get----return super().name
		set----super(SubClass, SubClass).name.__set__(self, value)
		delete----super(SubClass, SubClass).name.__delete__(self)
        如果只扩展一个方法的话，装饰器可以这样写----@ParentClass.name.setter和@ParentClass.name.getter;
		
15. 描述器就是一个实现了三个核心属性访问操作(set,get,delete)的类，分别为__get__，__set__和__delete__方法；
这些方法接受一个实例作为输入，之后相应地操作实例底层的字典；描述其只能在类级别被定义；
__get__方法就是确保绑定方法对象能被正确的创建；

16. 简化数据结构的初始化。在基类的初始化方法__init__中对传参与每个实例的可允许传参进行校验。

17. 定义接口和抽象基类：
    继承metaclass=abc.ABCMeta，方法加@abstractmethod
	抽象类的定义就是让别的类继承它并实现特定的抽象方法，抽象类不能被实例化；


21. 代理----一种编程模式，将某个操作转移给另一个对象来实现；
当需要代理的方法很多时，可以尝试使用__getattr__来实现；__getattr__是在属性不存在的时候才被调用；
代理模式：代理类中实例化时传被代理类的实例，并在代理类中实现__setattr__/__getattr__/__delattr__方法；
有个约定是：只代理那些不以下划线开头的属性； 

22. 定义多个构造器，定义__init__(*args)方法，另外的构造器--定义类方法，调用cls(*args);

23. __new__()----创建一个未初始化的实例，类方法中调用时，instance = cls.__new__(cls);

24. 通过字符串调用某个对象对应的方法；
    1. 直接getattr(obj, 'func')(*args)；
	2. operator.methodcaller('func', *args)(obj)；


26. nolocal允许用来修改闭包中的变量；






34. 元类控制器实例的创建
Python是一种动态语言，而动态语言和静态语言最大的不同，就是函数和类不是编译时定义的，而是运行时动态创建的。
class的定义是运行时动态创建的，而创建class的方法就是使用type()函数
定义：type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)
type()函数既可以返回一个对象的类型，又可以创建出新的类型
metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。
一个类定义时metaclass=定义的元类，元类中定义__call__()方法，当这个类实例化时会调用元类的__call__方法，
再调用自己的__init__方法；
单例模式：metaclass的实现：
class Singleton(type):
    def __init__(self, *args, **kwargs):
        self._instance = None
        super().__init__(*args, **kwargs)

    def __call__(self, *args, **kwargs):
        if not self._instance:
            self._instance = super().__call__(*args, **kwargs)
        return self._instance


class OnePerson(metaclass=Singleton):
    def __init__(self):
        print('create OnePerson instance')

缓存实例：
class Cached(type):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__cached = weakref.WeakValueDictionary()

    def __call__(self, *args):
        if args in self.__cached:
            return self.__cached[args]
        else:
            obj = super().__call__(*args)
            self.__cached[args] = obj
            return obj


class CachedInstance(metaclass=Cached):
    def __init__(self, name):
        print('create cached instance({!r})'.format(name))
        self.name = name

一个基本元类通常是继承type并重定义它的__new__()方法或者是__init__()方法；
比如定义__new__()方法：
class MyMeta(type):
    def __new__(self, clsname, bases, clsdict):
	# clsname is name of class being defined, bases is tuple of base classes, clsdict is class dictionary
	return super().__new__(cls, clsname, bases, clsdict)
另一种定义__init__()方法，
class MyMeta(type):
	def __init__(self, clsname, bases, clsdict):
		super().__init__(clsname, bases, clsdict)
为了使用这个元类，你通常要将它放到到一个顶级父类定义中，然后其他的类继承
这个顶级父类。例如：
class Root(metaclass=MyMeta):
	pass
class A(Root):
	pass
class B(Root):
	pass

元类的一个关键特点是它允许你在定义的时候检查类的内容。在重新定义init()方法中，
你可以很轻松的检查类字典、父类等等。并且，一旦某个元类被指定给了某个类，那么就会被继承到所有子类中去。

使用type.new_class()初始化新的类对象。
你需要做的只是提供类的名字、父类元组、关键字参数，以及一个用成员变量填充类字典的回调函数。
一个类的定义如下：
class Spam(Base, debug=True, typecheck=False):
	pass
那么可以将其翻译成如下的 new class() 调用形式：
Spam = types.new_class('Spam', (Base,),{'debug': True, 'typecheck': False},lambda ns: ns.update(cls_dict))
new class() 第四个参数最神秘，它是一个用来接受类命名空间的映射对象的函数。
通常这是一个普通的字典，但是它实际上是 prepare () 方法返回的任意对象。

另一种构造类对象：
Stock = collections.nametuple('Stock', ['name', 'shares', 'price'])


35. 实现上下文管理器
contextlib模块中@contextmanager装饰器
@contextmanager
def timethis(label):
    start_time = time.time()
    try:
        yield
    finally:
        end_time = time.time()
        print("{}: {}".format(label, (end_time - start_time)))


with timethis('counting'):
    n = 100000
    while n > 0:
yield之前的代码会在上下文管理器中作为__enter__()方法执行，所有再yield之后的代码会作为__exit__()方法执行，
如果出现了异常，代码会在yield那里抛出；

36. locals函数
locals函数可以得到一个局部变量字典，这样就可以从局部变量字典中取得修改过后的变量值；
每次它被调用的时候，locals()会获取局部变量值中的值并覆盖字典中相应的变量。

37. exec
exec(object[, globals[, locals]])
参数
object：必选参数，表示需要被指定的 Python 代码。它必须是字符串或 code 对象。
globals：可选参数，表示全局命名空间（存放全局变量），如果被提供，则必须是一个字典对象。
locals：可选参数，表示当前局部命名空间（存放局部变量），如果被提供，可以是任何映射对象。
如果该参数被忽略，那么它将会取与 globals 相同的值。
exec()最佳实践----这样b才是修改后的值
def test1():
    a = 10
    loc = {'a': a}
    glb = {}
    exec('b = a + 1', glb, loc)
    b = loc['b']
    print(loc)


41. 重新加载已经加载的模块
使用imp模块，imp.reload(module)----reload()擦除了模块底层字典的内容，并通过重新执行模块的源代码来刷新它。
模块对象本身的身份保持不变。因此，该操作在程序中所有已经被导入了的地方更新了模块。


43. 对字符串调用导入命令
import importlib
mod = importlib.import_module('urllib.request')
>>> u = mod.urlopen('http://www.python.org')
import module只是简单地执行和import相同的步骤，但是返回生成的模块对象。
你只需要将其存储在一个变量，然后像正常的模块一样使用。


44. urllib模块
params = {
    'name1': 'value1',
    'name2': 'value2'
}
querystring = parse.urlencode(params)
# querystring变成了这种形式name1=value1&name2=value2
发送一个简单的HTTP GET请求到远程服务器上----urllib.request.urlopen(url + '?' + querystring)
将参数编码后作为可选参数提供给urlopen()函数----urllib.request.urlopen(url, querystring.encode('ascii'))
你需要在发出的请求中提供一些自定义的 HTTP 头，例如修改 user-agent字段, 

46. cidrs地址计算
当给定一个IP地址，比如18.232.133.86/22，需要求一下这个IP所在网络的网络地址、子网掩码、广播i地址、
这个网络的第一台主机的IP地址：
斜线后是22并不是8的整数倍，直接很难看出结果，所以需要通过一系列的计算。
1.先用8的整数倍对22进行切割：22 =16+6 ，所以这个IP地址的前16位保持不动即18.232.
2.发现问题出在了第三个8位上，这8位中前面6位被拿来做了网络号，后面2位被拿去做了主机号，
所以将这8位转化为二进制得到10000101，拿出前6位为<100001>。这是得到了全部的网络号为 18.232.<100001>
3.将主机号全部置0便是网络地址，18.232.<100001><00>.<00000000>即网络地址为18.232.132.0
4.同时也得到了这个网络的第一台主机的ip地址，18.232.<100001><00>.<00000001>即18.232.132.1
5.将主机位全部置1便是广播地址，18.232.<100001><11>.<11111111>即18.232.135.255
6.子网掩码可以直接使用22计算即可，即前22位都为1，其余为0，即255.255.252.0
再举一例:
10.42.115.24/20
表示前面20位都是网路号，前16位固定，10.42网段的，在这115用二进制表示位01110011，再前4位固定，
也就是说最小的主机ip地址位10.42.112.0，后面12位全为1时，即最大主机号位10.42.127.255。
	
IPv6的128位地址通常写成8组，每组为四个十六进制数的形式。





50. 计算密集型函数
concurrent.futures.ProcessPoolExecutor
简单用法：
with ProcessPoolExecutor() as pool:
    do work in parallel using pool
其原理是，一个ProcessPoolExecutor创建N个独立的Python解释器，N是系统上面可用CPU的个数。
你可以通过提供可选参数给 ProcessPoolExecutor(N)来修改处理器数量。
这个处理池会一直运行到 with 块中最后一个语句执行完成，然后处理池被关闭。
不过，程序会一直等待直到所有提交的工作被处理完成。
被提交到池中的工作必须被定义为一个函数。
有两种方法去提交。如果你想让一个列表推导或一个map()操作并行执行的话，可使用pool.map():
def work(x):
	...
	return result
# Nonparallel code
results = map(work, data)
# Parallel implementation
with ProcessPoolExecutor() as pool:
	results = pool.map(work, data)
另外，你可以使用pool.submit()来手动的提交单个任务：
# Some function
def work(x):
	...
	return result
with ProcessPoolExecutor() as pool:
	...
	# Example of submitting work to the pool
	future_result = pool.submit(work, arg)
	# Obtaining the result (blocks until done)
	r = future_result.result()

51. 全局锁
全局解释锁(GIL),python线程被限制到同一时刻只允许一个线程执行这样的一个执行模型；
实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。
GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势
（比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。

52. 消息发布订阅模型
要实现发布/订阅的消息通信模式，通常要引入一个单独的交换机或网关，对象作为所有消息的中介；
也就是说，不直接将消息从一个任务发送给另一个任务，而是将其发送给交换机，然后由交换机发送给一个或多个被关联任务；
一个交换机就是一个普通对象，负责维护一个活跃的订阅者集合，并为绑定/解绑/发送消息提供相应的方法。

53. 生成器替换线程
yield语句会让它的生成器挂起它的执行，这样可以编写一个调度器，将生成器当作某种任务并使用任务协作切换来替换它们执行；






70. 网络与web编程
a. 使用socketserver库创建一个TCP服务器
class EchoHandler(BaseRequestHandler):
    def handle(self) -> None:
        print('Got connection from', self.client_address)
        while True:
            msg = self.request.recv(8192)
            if not msg:
                break
            self.request.send(msg)


if __name__ == "__main__":
    server = TCPServer(('', 20000), EchoHandler)
    server.serve_forever()
定义了一个特殊的处理类，实现了一个handler方法，用来为客户端连接服务。
request属性是客户端socket,client_address有客户端地址;
打开另外的python进程可以访问这个服务器;
s = socket.socket(AF_INET, SOCK_STREAM)
s.connect(('localhost', 20000))
s.send(b'hello')---必须是字节类型的;
s.recv(8192)
# s.sendto(b'hello', ('localhost', 20000))
# s.recvfrom(128)
注意：一般情况下这种服务器是单线程的，一次只能为一个客户端提供服务；
如果想处理多个客户端，可以初始化一个ForkingTCPServer或者ThreadingTCPServer对象；

from socket import socket, AF_INET, SOCK_DGRAM
s = socket(AF_INET, SOCK_DGRAM)
s.sendto(b'', ('localhost', 20000))


b.ipaddress使用
CIDR网络地址转换成所代表的所有IP----net = ipaddress.ip_network("10.42.115.0/24");
允许像数组一样索引取值----net[0],net.num_address---地址数;
创建一个ip----address = ipaddress.ip_address('10.42.115.99');
执行网路成员检查----address in net--True;
一个ip地址和网络地址能通过一个ip接口来指定:
inet = ipaddress.ip_interface('10.42.115.23/24');
inet.network = '10.42.115.23/24';
inet.ip = '10.42.115.23';

c. ssl模块为底层socket连接添加SSL的支持

d. 事件驱动 I/O
事件驱动 I/O 本质上来讲就是将基本 I/O 操作（比如读和写）转化为你程序需要处理的事件。
例如，当数据在某个 socket 上被接受后，它会转换成一个 receive 事件，
然后被你定义的回调方法或函数来处理。
select.select()调用，它会不断轮询文件描述符从而激活它。
在调用select()之前，时间循环会询问所有的处理器来决定哪一个想接受或发生。
然后它将结果列表提供给 select()。然后select()返回准备接受或发送的对象组成的列表。


71. fileinput
fileinput.input() 创建并返回一个 FileInput 类的实例。
可以python fileinput.py file_name将文件中的内容打印出来；
fileinput.input(file_name)----遍历file中的内容；

72. xml_rpc构造简单远程调用服务
远程调用理解：在本地调用远程机器上的服务；
xmlrpc模块的实现---创建一个服务器实例，通过它的方法registry_function()来注册函数，
                  然后使用方法server_forever()启动它。

73. 向标准错误打印一条消息并返回某个非零状态码来终止程序运行
raise SystemExit('It failed!')----将消息打印在sys.stderr中,然后程序以状态码1退出；

74. Linkedlist
删除倒数第n个节点
a. 构造dummy = LinkedList(0, head)   先获得链表的长度，之后遍历进行赋值；
b. 构造dummy = LinkedList(0, head)  将各个node放入栈中，遍历n次进行pop()，之后赋值；
c. 构造dummy = LinkedList(0, head)  双指针，一个链表先向前n步，这样两个链表相差n,当第一个链表走到最后的时候，第二个链表就是倒数第n个元素；




